{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "Clarion built-in function definitions for signature help and IntelliSense",
  "functions": [
    {
      "name": "CHOOSE",
      "signatures": [
        {
          "params": ["expression", "value", "value"],
          "returnType": "varies",
          "description": "Index-based selection: Returns the value parameter at position specified by expression. Expression must be a positive integer. If out of range, returns last value. Return type depends on value parameters (LONG if all LONG, DECIMAL if LONG/DECIMAL mix, STRING if any STRING, REAL otherwise)."
        },
        {
          "params": [
            { "name": "expression", "optional": false },
            { "name": "value", "optional": false },
            { "name": "value", "optional": false },
            { "name": "value...", "optional": true }
          ],
          "returnType": "varies",
          "description": "Index-based selection with variable values: Returns the value at position specified by expression (1-based index). Can have 2 or more value parameters. Return type depends on value types."
        },
        {
          "params": ["condition"],
          "returnType": "LONG",
          "description": "Boolean evaluation: Evaluates condition and returns 1 (true) or 0 (false). Use when you only need to convert a boolean to numeric."
        },
        {
          "params": [
            { "name": "condition", "optional": false },
            { "name": "truevalue", "optional": true },
            { "name": "falsevalue", "optional": true }
          ],
          "returnType": "varies",
          "description": "Boolean selection: Returns truevalue if condition is true, falsevalue if false. If values not provided, returns 1 (true) or 0 (false). Common use: CHOOSE(expression, 'Yes', 'No')."
        }
      ]
    },
    {
      "name": "CLIP",
      "signatures": [
        {
          "params": ["STRING string"],
          "returnType": "STRING",
          "description": "Removes trailing spaces from a string and returns the trimmed result. Frequently used with concatenation. Not needed for CSTRING or PSTRING types."
        }
      ]
    },
    {
      "name": "SUB",
      "signatures": [
        {
          "params": ["STRING string", "LONG position", "LONG length"],
          "returnType": "STRING",
          "description": "Returns a substring starting at position for length characters. Position can be negative to count from end (-1 is last char). Zero-based in Clarion#."
        }
      ]
    },
    {
      "name": "UPPER",
      "signatures": [
        {
          "params": ["STRING string"],
          "returnType": "STRING",
          "description": "Converts all alphabetic characters in the string to uppercase. Non-alphabetic characters are unchanged."
        }
      ]
    },
    {
      "name": "LOWER",
      "signatures": [
        {
          "params": ["STRING string"],
          "returnType": "STRING",
          "description": "Converts all alphabetic characters in the string to lowercase. Non-alphabetic characters are unchanged."
        }
      ]
    },
    {
      "name": "LEN",
      "signatures": [
        {
          "params": ["STRING string"],
          "returnType": "LONG",
          "description": "Returns the total length of the string including trailing spaces. For length without trailing spaces, use LEN(CLIP(string))."
        }
      ]
    },
    {
      "name": "FORMAT",
      "signatures": [
        {
          "params": ["numeric value", "STRING picture"],
          "returnType": "STRING",
          "description": "Formats a numeric value (BYTE/SHORT/LONG/REAL/DECIMAL) into a string using a picture token (e.g., '@n10.2' for decimals, '@d1' for dates)."
        }
      ]
    },
    {
      "name": "MESSAGE",
      "signatures": [
        {
          "params": [
            { "name": "STRING text", "optional": false },
            { "name": "STRING caption", "optional": true },
            { "name": "LONG icon", "optional": true },
            { "name": "LONG buttons", "optional": true },
            { "name": "LONG default", "optional": true },
            { "name": "LONG style", "optional": true }
          ],
          "returnType": "BYTE",
          "description": "Displays a message box. Text is required, all other parameters optional (caption, icon, buttons, default button, and style/mode). Returns button code indicating which button was clicked. Use pipe character (|) in text for multi-line messages.",
          "syntax": "MESSAGE(text [,caption] [,icon] [,buttons] [,default] [,style])"
        }
      ]
    },
    {
      "name": "EOF",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "LONG",
          "description": "Returns non-zero (true) when the last record has been read by NEXT/SKIP. Not supported by all drivers - prefer checking ERRORCODE() after NEXT instead."
        }
      ]
    },
    {
      "name": "EXISTS",
      "signatures": [
        {
          "params": ["STRING filename"],
          "returnType": "LONG",
          "description": "Returns non-zero if the specified file or directory exists on disk. Can include full path or use current directory. Returns 1 if found, 0 if not."
        }
      ]
    },
    {
      "name": "RECORDS",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "LONG",
          "description": "Returns the total number of records currently in the file. File must be open. Useful for progress bars and pre-sizing queues."
        }
      ]
    },
    {
      "name": "NAME",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "STRING",
          "description": "Returns the filename from the FILE's NAME attribute without the path. To get the full path, use FULLNAME attribute instead."
        }
      ]
    },
    {
      "name": "PATH",
      "signatures": [
        {
          "params": [],
          "returnType": "STRING",
          "description": "Returns the current working directory as a string. This is where files are created/opened by default if no path is specified."
        }
      ]
    },
    {
      "name": "COPY",
      "signatures": [
        {
          "params": ["STRING source", "STRING destination"],
          "returnType": "",
          "description": "Copies a file from source path to destination path. Overwrites destination if it exists. Check ERRORCODE() to verify success."
        }
      ]
    },
    {
      "name": "REMOVE",
      "signatures": [
        {
          "params": ["STRING filename"],
          "returnType": "",
          "description": "Deletes the specified file from disk permanently. Check ERRORCODE() after to verify success. Cannot be undone."
        }
      ]
    },
    {
      "name": "RENAME",
      "signatures": [
        {
          "params": ["STRING oldname", "STRING newname"],
          "returnType": "",
          "description": "Renames a file or directory from oldname to newname. Can also move files between directories. Check ERRORCODE() for success."
        }
      ]
    },
    {
      "name": "ERRORCODE",
      "signatures": [
        {
          "params": [],
          "returnType": "STRING",
          "description": "Returns the error code number as a string from the most recent file operation (OPEN, GET, ADD, etc.). Returns empty string if no error. Check after every file operation."
        }
      ]
    },
    {
      "name": "ERROR",
      "signatures": [
        {
          "params": [],
          "returnType": "STRING",
          "description": "Returns the full error message text from the most recent file operation. More descriptive than ERRORCODE(). Returns empty string if no error."
        }
      ]
    },
    {
      "name": "FILEERROR",
      "signatures": [
        {
          "params": [],
          "returnType": "STRING",
          "description": "Returns the file driver-specific error message from the most recent operation. Provides low-level driver details beyond ERROR()."
        }
      ]
    },
    {
      "name": "FILEERRORCODE",
      "signatures": [
        {
          "params": [],
          "returnType": "LONG",
          "description": "Returns the file driver-specific error code as a numeric value. Useful for programmatic error handling and driver-specific error checking."
        }
      ]
    },
    {
      "name": "ADD",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Adds a new record to a file. The record buffer contains the data to write. Check ERRORCODE() after to verify success."
        },
        {
          "params": ["FILE file", "LONG length"],
          "returnType": "",
          "description": "Adds a new record to a file with specified byte length. Used for variable-length records or MEMO fields."
        },
        {
          "params": ["QUEUE queue"],
          "returnType": "",
          "description": "Adds a new entry to the end of a queue. The queue structure fields contain the data to add."
        },
        {
          "params": ["QUEUE queue", "LONG position"],
          "returnType": "",
          "description": "Inserts a new entry into a queue at the specified position (1-based). Existing entries shift down."
        }
      ]
    },
    {
      "name": "PUT",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Updates the current file record (last one read by GET/NEXT/PREVIOUS) with data from the record buffer."
        },
        {
          "params": ["FILE file", "LONG pointer"],
          "returnType": "",
          "description": "Writes the record buffer to a specific record number in the file. Used for direct/random access updates."
        },
        {
          "params": ["FILE file", "LONG pointer", "LONG length"],
          "returnType": "",
          "description": "Writes the record buffer to a specific position with specified byte length. For variable-length records."
        },
        {
          "params": ["QUEUE queue"],
          "returnType": "",
          "description": "Updates the current queue entry (last one accessed by GET) with data from the queue structure."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Updates the current view record (last one read by NEXT/PREVIOUS) in the view's primary file."
        }
      ]
    },
    {
      "name": "GET",
      "signatures": [
        {
          "params": ["FILE file", "KEY key"],
          "returnType": "",
          "description": "Reads a record from file by matching the key fields. Key fields in record buffer must be set first. Posts error if not found."
        },
        {
          "params": ["FILE file", "LONG pointer"],
          "returnType": "",
          "description": "Reads a specific record by record number (1-based) into the record buffer. Used for direct/random access."
        },
        {
          "params": ["QUEUE queue", "LONG position"],
          "returnType": "",
          "description": "Retrieves a queue entry at the specified position (1-based) into the queue structure fields."
        }
      ]
    },
    {
      "name": "DELETE",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Removes the current record from the file (last one accessed by GET/NEXT/PREVIOUS/ADD/PUT). Removes all key entries too."
        },
        {
          "params": ["QUEUE queue"],
          "returnType": "",
          "description": "Removes the current queue entry (last one accessed by GET or ADD). All subsequent entries shift up. Memory is deallocated."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Removes the current record from the view's primary file (last accessed by NEXT/PREVIOUS). Secondary files are not affected."
        }
      ]
    },
    {
      "name": "SET",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Positions file pointer to the beginning of the file in record number sequence. Used before NEXT to read from start."
        },
        {
          "params": ["FILE file", "KEY key"],
          "returnType": "",
          "description": "Positions file pointer to the start of a specific key's sequence. Key fields in record buffer define the position. Used before NEXT."
        },
        {
          "params": ["FILE file", "LONG pointer"],
          "returnType": "",
          "description": "Positions file pointer to a specific record number. Used before NEXT to start sequential reading from that record."
        },
        {
          "params": ["KEY key"],
          "returnType": "",
          "description": "Positions to the start of a specific key's sequence for the implied file. Key fields define position. Used before NEXT."
        }
      ]
    },
    {
      "name": "NEXT",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Reads the next record in the current sequence (set by SET or last key used) into the record buffer. Returns error at end of file."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Reads the next record in the view's sequence into the view structure. Joins related file records automatically."
        }
      ]
    },
    {
      "name": "PREVIOUS",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Reads the previous record in the current sequence (opposite of NEXT) into the record buffer. Returns error at beginning of file."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Reads the previous record in the view's sequence into the view structure. Moves backward through the result set."
        }
      ]
    },
    {
      "name": "OPEN",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Opens a file for reading and writing. Creates the file if it doesn't exist (unless CREATE attribute is 0). Check ERRORCODE() after."
        },
        {
          "params": ["FILE file", "LONG mode"],
          "returnType": "",
          "description": "Opens a file with specific access mode (Read/Write + Deny Write/Read/None/All). Mode controls user access and multi-user sharing."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Opens a VIEW for processing. The component files must already be open. Use SET before OPEN to establish sequence."
        },
        {
          "params": ["WINDOW window"],
          "returnType": "",
          "description": "Activates a WINDOW for processing. Nothing displays until DISPLAY or ACCEPT is encountered. Allows pre-display customization."
        },
        {
          "params": ["WINDOW window", "WINDOW owner"],
          "returnType": "",
          "description": "Opens a WINDOW with an owner window. The owned window appears on top and is auto-hidden/closed with its owner."
        },
        {
          "params": ["APPLICATION app"],
          "returnType": "",
          "description": "Activates an APPLICATION window. Nothing displays until DISPLAY or ACCEPT. Use for main application window setup."
        },
        {
          "params": ["APPLICATION app", "WINDOW owner"],
          "returnType": "",
          "description": "Opens an APPLICATION with an owner window. Establishes parent-child window relationship."
        },
        {
          "params": ["REPORT report"],
          "returnType": "",
          "description": "Activates a REPORT structure for printing. Must OPEN before printing any REPORT structures."
        }
      ]
    },
    {
      "name": "CLOSE",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Closes an open file and flushes any pending writes. Frees memory and releases locks. Always close files when done."
        },
        {
          "params": ["VIEW view"],
          "returnType": "",
          "description": "Closes an open VIEW. Automatically closed on RETURN if declared locally. State of component files becomes undefined."
        },
        {
          "params": ["WINDOW window"],
          "returnType": "",
          "description": "Closes an APPLICATION or WINDOW. Releases memory and redraws underlying screen. Auto-closes child windows first."
        },
        {
          "params": ["REPORT report"],
          "returnType": "",
          "description": "Closes a REPORT structure. Prints final page FOOTER and group FOOTERs. Deletes PREVIEW metafiles if applicable."
        }
      ]
    },
    {
      "name": "CREATE",
      "signatures": [
        {
          "params": ["FILE file"],
          "returnType": "",
          "description": "Creates an empty data file with the structure defined in the FILE declaration. Overwrites existing file if it exists."
        },
        {
          "params": ["FILE file", "LONG mode"],
          "returnType": "",
          "description": "Creates an empty data file with a specific create mode. Mode controls file creation behavior and options."
        }
      ]
    },
    {
      "name": "INCLUDE",
      "signatures": [
        {
          "params": [
            { "name": "STRING filename", "optional": false },
            { "name": "STRING section", "optional": true }
          ],
          "returnType": "",
          "description": "Compiler directive that includes source code from another file. Section parameter is optional - if omitted, includes entire file. If provided, includes only the specified SECTION. Extension .CLW assumed if omitted.",
          "syntax": "INCLUDE(filename [,section])"
        }
      ]
    },
    {
      "name": "MEMBER",
      "signatures": [
        {
          "params": [
            { "name": "STRING program", "optional": true }
          ],
          "returnType": "",
          "description": "Compiler directive that identifies this source file as a MEMBER module. Program parameter is optional - omit for single-program applications, specify for multi-program solutions. Must appear at top of file before any MAP.",
          "syntax": "MEMBER([program])"
        }
      ]
    },
    {
      "name": "CLEAR",
      "signatures": [
        {
          "params": [
            { "name": "variable label", "optional": false },
            { "name": "LONG n", "optional": true }
          ],
          "returnType": "",
          "description": "Clears a variable, GROUP, RECORD, QUEUE, CLASS, or FILE. N parameter is optional - if omitted, clears to default values (0, blank, etc.). If n=1, sets to highest possible value (all ASCII 255). If n=-1, sets to lowest value (all ASCII 0). Arrays are cleared entirely.",
          "syntax": "CLEAR(variable [,n])"
        }
      ]
    },
    {
      "name": "PROGRAM",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Declares the main program module. Only one PROGRAM per application. Must be the first declaration in the main source file. Use MEMBER for additional source modules that contain procedures called by the program."
        }
      ]
    },
    {
      "name": "CODE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Begins the executable code section of a PROCEDURE. Must appear after all data declarations (variables, files, windows, etc.). Everything after CODE until END is executable statements."
        }
      ]
    },
    {
      "name": "OMIT",
      "signatures": [
        {
          "params": [
            { "name": "STRING terminator", "optional": false },
            { "name": "expression", "optional": true }
          ],
          "returnType": "",
          "description": "Compiler directive that omits a block of source code from compilation. Expression parameter is optional - if omitted, always omits code. If provided (typically an EQUATE), omits code conditionally when expression is TRUE. Block ends at the line containing the terminator string.",
          "syntax": "OMIT(terminator [,expression])"
        }
      ]
    },
    {
      "name": "COMPILE",
      "signatures": [
        {
          "params": [
            { "name": "STRING terminator", "optional": false },
            { "name": "expression", "optional": true }
          ],
          "returnType": "",
          "description": "Compiler directive that includes a block of source code in compilation. Expression parameter is optional - if omitted, always compiles code. If provided (typically an EQUATE), compiles code conditionally when expression is TRUE. Block ends at the line containing the terminator string.",
          "syntax": "COMPILE(terminator [,expression])"
        }
      ]
    },
    {
      "name": "MAP",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Declares a block of external procedure prototypes. Used in PROGRAM or MEMBER modules to declare procedures from other modules. Contains MODULE() sections and/or individual procedure prototypes. Ends with END."
        }
      ]
    },
    {
      "name": "MODULE",
      "signatures": [
        {
          "params": ["STRING sourcefile"],
          "returnType": "",
          "description": "Declares a module block within a MAP structure. Names a MEMBER source file or external library containing procedure definitions. Contains procedure prototypes and ends with END. Can only be used inside MAP...END blocks."
        }
      ]
    },
    {
      "name": "IF",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Initiates a conditional execution structure. Executes statements based on logical expression evaluation. Zero or blank evaluates as false, anything else is true. Structure ends with END statement."
        }
      ]
    },
    {
      "name": "THEN",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Optional keyword following IF or ELSIF. Statements after THEN execute when the preceding logical expression is true. Must appear on same line as IF or ELSIF if used."
        }
      ]
    },
    {
      "name": "ELSIF",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Evaluates an alternate condition in an IF structure. Logical expression following ELSIF is evaluated only when all preceding IF or ELSIF conditions were false. Can have multiple ELSIF clauses."
        }
      ]
    },
    {
      "name": "ELSE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Executes statements when all preceding IF and ELSIF conditions evaluate as false. Optional but must be last option in IF structure if used. Provides default action when no conditions are true."
        }
      ]
    },
    {
      "name": "TO",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Specifies a range in LOOP iterations or CASE OF statements.\n\nIn LOOP: i = initial TO limit [BY step] - Specifies terminating value. When counter exceeds limit (or is less than, if step is negative), loop terminates. Limit expression evaluated once at loop start.\n\nIn CASE: OF expression TO expression - Allows a range of values. Statements execute if condition falls within the inclusive range. Both expressions are evaluated even if condition is less than lower boundary."
        }
      ]
    },
    {
      "name": "BY",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Specifies the increment/decrement step in a LOOP counter iteration. Used with TO: i = initial TO limit BY step. If omitted, counter increments by 1. Negative values cause decrement. Step expression evaluated once at loop start."
        }
      ]
    },
    {
      "name": "UNTIL",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Evaluates condition to terminate LOOP. When on LOOP statement, tests before each iteration. When terminating LOOP structure (after statements), tests after each iteration. Loop terminates when expression evaluates to true."
        }
      ]
    },
    {
      "name": "WHILE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Evaluates condition to continue LOOP. When on LOOP statement, tests before each iteration. When terminating LOOP structure (after statements), tests after each iteration. Loop terminates when expression evaluates to false."
        }
      ]
    },
    {
      "name": "VAL",
      "signatures": [
        {
          "params": [
            { "name": "STRING character", "optional": false }
          ],
          "returnType": "BYTE | USHORT | SIGNED",
          "description": "Returns the numeric code of a character. Returns BYTE for ANSI strings, USHORT for Unicode strings, or SIGNED if type cannot be determined at compile time. Use TOANSI or TOUNICODE to force specific encoding."
        }
      ]
    },
    {
      "name": "SIZE",
      "signatures": [
        {
          "params": [
            { "name": "variable | constant | picture", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Returns memory size in bytes of a variable, constant, or picture. Evaluated at compile time if size is known, otherwise at runtime. For reference variables, retrieves size from the variable. For arrays with variable dimensions, calculates based on element size and actual count."
        }
      ]
    },
    {
      "name": "CASE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Initiates selective execution structure based on condition evaluation. Executes first matching OF/OROF statement group. More efficient than IF/ELSIF for multiple equivalence tests. Terminates with END statement."
        }
      ]
    },
    {
      "name": "OF",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Specifies an expression to compare with CASE condition. Statements following OF execute when expression equals CASE condition. Can use ranges with TO keyword. Multiple OF options allowed in CASE structure."
        }
      ]
    },
    {
      "name": "OROF",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Adds alternative expression to preceding OF option. Statements execute when either OROF expression or preceding OF expression equals CASE condition. Can be on same line or separate line. Control falls into OROF statements from preceding statements."
        }
      ]
    },
    {
      "name": "NEW",
      "signatures": [
        {
          "params": [
            { "name": "datatype", "optional": false }
          ],
          "returnType": "reference",
          "description": "Allocates heap memory for a new instance of the specified data type. Used on source side of reference assignment (reference &= NEW(datatype)). Memory is automatically initialized to blank/zero and must be explicitly de-allocated with DISPOSE to prevent memory leaks. Parentheses around datatype are optional."
        }
      ]
    },
    {
      "name": "DISPOSE",
      "signatures": [
        {
          "params": [
            { "name": "reference", "optional": false }
          ],
          "returnType": "",
          "description": "De-allocates heap memory previously allocated by NEW statement. Failure to call DISPOSE creates memory leaks. Reference may be NULL with no ill effects. Warning: Disposing a reference still in use (e.g., QUEUE in LIST control) may cause GPF. DISPOSE(SELF) must be last statement in procedure."
        }
      ]
    },
    {
      "name": "ACCEPT",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Initiates event processing loop for WINDOW or APPLICATION structures. Processes user input, mouse events, and control events. Loop cycles automatically when field-specific events occur. Use EVENT(), FIELD(), ACCEPTED() to determine what happened. Terminates with BREAK or implicit events like CloseWindow."
        }
      ]
    },
    {
      "name": "CYCLE",
      "signatures": [
        {
          "params": [
            { "name": "label", "optional": true }
          ],
          "returnType": "",
          "description": "Transfers control back to top of LOOP or ACCEPT structure. Optional label allows cycling to outer nested loops. In ACCEPT loop, terminates certain automatic actions before performed (Iconize, Maximize, Move, Size, Restore, CloseWindow events)."
        }
      ]
    },
    {
      "name": "SORT",
      "signatures": [
        {
          "params": [
            { "name": "QUEUE queue", "optional": false },
            { "name": "[+|-]key", "optional": false }
          ],
          "returnType": "",
          "description": "Reorders entries in a QUEUE by specified key fields. Supports up to 16 keys separated by commas. Leading +/- indicates ascending/descending order. Keys must include PRE prefix if QUEUE has one. Can use NAME attributes as string or comparison function. Entries with identical keys maintain relative position."
        }
      ]
    },
    {
      "name": "RETURN",
      "signatures": [
        {
          "params": [
            { "name": "expression", "optional": true }
          ],
          "returnType": "",
          "description": "Terminates PROGRAM or PROCEDURE and returns control to caller. Expression required for procedures returning values (may be NULL for reference returns). Automatically closes local APPLICATION/WINDOW/REPORT/VIEW/QUEUE structures. Implicit RETURN occurs at end if not specified. Closes program and files when used in PROGRAM."
        }
      ]
    },
    {
      "name": "OMITTED",
      "signatures": [
        {
          "params": [
            { "name": "LONG parameter", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Tests whether a procedure parameter was actually passed when called. Returns 1 (true) if parameter was omitted, 0 (false) if passed. Parameter is ordinal position number (1, 2, 3, etc.) or parameter name. Used to detect optional parameters in called procedures. Can test any parameter type including SELF, references, arrays, structures."
        }
      ]
    },
    {
      "name": "FREE",
      "signatures": [
        {
          "params": ["QUEUE queue"],
          "returnType": "",
          "description": "Deletes all entries from a QUEUE and deallocates memory. Does not clear the queue's data buffer. Important: If queue contains reference variables or ANY fields, CLEAR each entry before FREE to avoid memory leaks."
        }
      ]
    },
    {
      "name": "DISPLAY",
      "signatures": [
        {
          "params": [
            { "name": "control first", "optional": true },
            { "name": "control last", "optional": true }
          ],
          "returnType": "",
          "description": "Writes contents of USE variables to their associated controls. All parameters optional - if omitted, displays all controls. If first only, displays that control. If both provided, displays range from first to last. Controls can be field numbers or field equate labels.",
          "syntax": "DISPLAY([first] [,last])"
        }
      ]
    },
    {
      "name": "LOOP",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Initiates an iterative statement execution structure. Forms: LOOP (infinite), LOOP count TIMES, LOOP i=initial TO limit BY step, LOOP UNTIL expression, LOOP WHILE expression. Must end with END or UNTIL/WHILE terminator."
        }
      ]
    },
    {
      "name": "PRAGMA",
      "signatures": [
        {
          "params": [
            { "name": "string", "optional": false }
          ],
          "returnType": "",
          "description": "Compiler directive that sends project system statements from source code. Format: PRAGMA('project(statement)'), PRAGMA('compile(options)'), or PRAGMA('link(options)'). Dynamically adds pragma settings to project. Commonly used to control compilation, linking, and optimization settings from within code.",
          "syntax": "PRAGMA(string)"
        }
      ]
    },
    {
      "name": "EQUATE",
      "signatures": [
        {
          "params": [
            { "name": "value", "optional": false }
          ],
          "returnType": "",
          "description": "Assigns a label to a constant value, picture token, data type, or another label. Creates compile-time constant that uses no runtime memory. Used for readability and maintainability (e.g., TRUE EQUATE(1), PI EQUATE(3.1415927)). Cannot equate to itself. In ITEMIZE structure, value parameter is optional.",
          "syntax": "label EQUATE([constant] | picture | type | label)"
        }
      ]
    },
    {
      "name": "PROCEDURE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Defines executable code section that can be called from within a PROGRAM.\n\nPrototype (in MAP/CLASS): Declares procedure signature with optional parameters and return type.\nSyntax: label PROCEDURE[(params)] [,returnType] [,attributes]\n\nImplementation: Defines the actual executable code.\nSyntax: label PROCEDURE[(params)]\n       [local data]\n       CODE\n       statements\n       [RETURN(value)]\n\nFor CLASS methods, use ClassName.MethodName PROCEDURE format. Can return values when prototyped with return type. Must have matching prototype in MAP or CLASS."
        }
      ]
    },
    {
      "name": "FUNCTION",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Legacy synonym for PROCEDURE. In modern Clarion, PROCEDURE and FUNCTION are identical - both can return values when prototyped with a return type. FUNCTION keyword retained for backward compatibility with older DOS-era code where FUNCTION returned values and PROCEDURE did not."
        }
      ]
    },
    {
      "name": "BAND",
      "signatures": [
        {
          "params": [
            { "name": "value", "optional": false },
            { "name": "mask", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Performs bitwise AND operation. Returns LONG with 1 in bit positions where both value and mask contain 1, zeroes elsewhere. Used to test if specific bits are on/off. Both parameters converted to LONG if necessary.",
          "syntax": "BAND(value, mask)"
        }
      ]
    },
    {
      "name": "BOR",
      "signatures": [
        {
          "params": [
            { "name": "value", "optional": false },
            { "name": "mask", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Performs bitwise OR operation. Returns LONG with 1 in bit positions where value, mask, or both contain 1, zeroes elsewhere. Used to unconditionally turn on (set to 1) specific bits. Both parameters converted to LONG if necessary.",
          "syntax": "BOR(value, mask)"
        }
      ]
    },
    {
      "name": "BXOR",
      "signatures": [
        {
          "params": [
            { "name": "value", "optional": false },
            { "name": "mask", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Performs bitwise exclusive OR operation. Returns LONG with 1 in bit positions where value and mask differ, 0 where they match. Used to toggle bits or compare bit patterns. Both parameters converted to LONG if necessary.",
          "syntax": "BXOR(value, mask)"
        }
      ]
    },
    {
      "name": "BSHIFT",
      "signatures": [
        {
          "params": [
            { "name": "value", "optional": false },
            { "name": "count", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Performs bit shift operation. Positive count shifts left (toward high order), negative shifts right (toward low order). Zero bits fill vacated positions. Returns shifted LONG value. Shifting left by N multiplies by 2^N, right divides by 2^N.",
          "syntax": "BSHIFT(value, count)"
        }
      ]
    },
    {
      "name": "ADDRESS",
      "signatures": [
        {
          "params": [
            { "name": "variable", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Returns the memory address of a variable or PROCEDURE. Used to pass addresses to external libraries written in other languages, or for reference assignment. Parameter can be any data item label or PROCEDURE name.",
          "syntax": "ADDRESS(variable)"
        }
      ]
    },
    {
      "name": "NOT",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Boolean logical NOT operator. Reverses the logical value of an expression - returns TRUE (1) if expression is FALSE (0), returns FALSE (0) if expression is TRUE. Can also use tilde (~) as synonym. Example: IF NOT Condition or IF ~Flag.",
          "syntax": "NOT expression"
        }
      ]
    },
    {
      "name": "END",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Terminates a data declaration structure (GROUP, CLASS, FILE, RECORD, etc.) or compound executable statement (IF, LOOP, CASE, ACCEPT, etc.). Functionally equivalent to period (.). By convention, END aligns with structure start and is used for multi-line structures. Multiple periods on one line can replace multiple END statements.",
          "syntax": "END"
        }
      ]
    },
    {
      "name": "ASSERT",
      "signatures": [
        {
          "params": [
            { "name": "expression", "optional": false },
            { "name": "message", "optional": true }
          ],
          "returnType": "",
          "description": "Debugging statement that evaluates an expression that should always be TRUE. If FALSE and debug is on, displays error message with line number and source file. Optional message parameter (up to 64K) shown in dialog. Use to catch erroneous assumptions. Enable in release builds with project define: asserts=>on",
          "syntax": "ASSERT(expression [,message])"
        }
      ]
    },
    {
      "name": "?",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Multi-purpose symbol with context-dependent meaning:\n\n1. Field Equate Label: Prefix for auto-generated control labels (e.g., ?Button1, ?String1)\n2. Generic Label: Used alone as a label for controls without specific names\n3. Debug-Only Statement: When placed in column 0 (first character) before a statement in CODE section, that statement only executes in DEBUG mode (ignored in release builds)\n\nExample: ?MyButton BUTTON('OK') or ?STOP('Debug point')",
          "syntax": "?[label] or ?statement (column 0)"
        }
      ]
    },
    {
      "name": "SELF",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Implicit reference to current CLASS instance within CLASS methods. Automatically passed as first parameter to non-static methods. Used to access current object's properties and methods. In method implementation, can be explicit parameter or implicit. Example: SELF.PropertyName or SELF.MethodName()",
          "syntax": "SELF.member"
        }
      ]
    },
    {
      "name": "PARENT",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Reference to parent CLASS in derived CLASS methods. Used to call parent class implementation of overridden methods or access parent class members. Enables calling base class functionality from derived class. Example: PARENT.MethodName() calls parent's version of method.",
          "syntax": "PARENT.member"
        }
      ]
    },
    {
      "name": "INT",
      "signatures": [
        {
          "params": [
            { "name": "expression", "optional": false }
          ],
          "returnType": "REAL or DECIMAL",
          "description": "Returns the integer portion of a numeric expression. No rounding is performed - simply truncates the fractional part. Sign remains unchanged. Example: INT(8.5) returns 8, INT(-5.9) returns -5.",
          "syntax": "INT(expression)"
        }
      ]
    },
    {
      "name": "ROUND",
      "signatures": [
        {
          "params": [
            { "name": "expression", "optional": false },
            { "name": "order", "optional": false }
          ],
          "returnType": "DECIMAL or REAL",
          "description": "Returns value rounded to a power of ten. Order specifies rounding precision (1, 10, 100, 0.1, 0.01, etc.). If order not exact power of 10, uses next lowest. Efficient as BCD operation when order is LONG or DECIMAL. Example: ROUND(5163,100) returns 5200, ROUND(51.64,.01) returns 51.64",
          "syntax": "ROUND(expression, order)"
        }
      ]
    },
    {
      "name": "VAL",
      "signatures": [
        {
          "params": [
            { "name": "character", "optional": false }
          ],
          "returnType": "BYTE, USHORT or SIGNED",
          "description": "Returns the numeric code of a character. Returns BYTE for ANSI strings, USHORT for Unicode strings, or SIGNED if type can't be determined. Use TOANSI or TOUNICODE to force specific encoding. Example: VAL('A') returns 65, VAL('Ж') returns 1046",
          "syntax": "VAL(character)"
        }
      ]
    },
    {
      "name": "CHR",
      "signatures": [
        {
          "params": [
            { "name": "code", "optional": false },
            { "name": "unicode", "optional": true }
          ],
          "returnType": "STRING (ANSI or Unicode character)",
          "description": "Returns single ANSI or Unicode character for given numeric code. If unicode parameter omitted or zero, returns ANSI character. If unicode is non-zero, returns Unicode character. Example: CHR(65) returns 'A', CHR(1046,1) returns Cyrillic 'Ж'",
          "syntax": "CHR(code [,unicode])"
        }
      ]
    },
    {
      "name": "DO",
      "signatures": [
        {
          "params": [
            { "name": "label", "optional": false }
          ],
          "returnType": "",
          "description": "Executes a ROUTINE local to PROGRAM or PROCEDURE. When ROUTINE completes, control returns to statement following DO. ROUTINE can only be called within CODE section containing it. Use EXIT to leave ROUTINE early, or let it complete naturally.",
          "syntax": "DO label"
        }
      ]
    },
    {
      "name": "EXIT",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Immediately leaves a ROUTINE and returns control to statement following the DO that called it. Different from RETURN which exits entire PROCEDURE. EXIT not required - ROUTINE terminates automatically when statements complete.",
          "syntax": "EXIT"
        }
      ]
    },
    {
      "name": "ROUTINE",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Declares a local subroutine within PROCEDURE. Can have optional DATA/CODE sections for local variables. Called with DO statement. Cannot duplicate PROCEDURE label. Useful for organizing code within procedures without overhead of separate procedure calls.",
          "syntax": "label ROUTINE\n[DATA\n  local data\nCODE]\n  statements"
        }
      ]
    },
    {
      "name": "EXECUTE",
      "signatures": [
        {
          "params": [
            { "name": "expression", "optional": false }
          ],
          "returnType": "",
          "description": "Single statement execution structure. Executes statement at position based on expression value (1=first, 2=second, etc.). Can use BEGIN/END for multi-statement blocks. Optional ELSE clause for out-of-range values. More efficient than IF/ELSIF or CASE for numeric selection. Must terminate with END.",
          "syntax": "EXECUTE expression\n  statement1\n  statement2\n  [BEGIN...END]\n  [ELSE statement]\nEND"
        }
      ]
    },
    {
      "name": "BEGIN",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Groups multiple statements into single executable structure. Primarily used within EXECUTE to treat several statements as one. Must be terminated by END or period. Allows multiple lines of code where single statement is expected.",
          "syntax": "BEGIN\n  statements\nEND"
        }
      ]
    },
    {
      "name": "ALL",
      "signatures": [
        {
          "params": [
            { "name": "string", "optional": false },
            { "name": "length", "optional": true }
          ],
          "returnType": "STRING",
          "description": "Returns string containing repetitions of character sequence. If length omitted, returns 255 characters. Useful for creating padding, separators, or initialized strings. Example: ALL('*',25) returns 25 asterisks, ALL('.') returns 255 dots.",
          "syntax": "ALL(string [,length])"
        }
      ]
    },
    {
      "name": "INSTRING",
      "signatures": [
        {
          "params": [
            { "name": "substring", "optional": false },
            { "name": "string", "optional": false },
            { "name": "step", "optional": true },
            { "name": "start", "optional": true }
          ],
          "returnType": "UNSIGNED",
          "description": "Searches for substring in string. Returns position (0 if not found). Step controls search interval (1=every char, 2=every other char, -1=right-to-left). Start specifies starting position. Returns step number when found, not character position if step > 1. Should CLIP variable substring to avoid trailing space matches.",
          "syntax": "INSTRING(substring, string [,step] [,start])"
        }
      ]
    },
    {
      "name": "BREAK",
      "signatures": [
        {
          "params": [
            { "name": "label", "optional": true }
          ],
          "returnType": "",
          "description": "Immediately exits LOOP or ACCEPT structure and transfers control to first statement after terminator (END/WHILE/UNTIL). Optional label allows breaking out of nested loops by specifying which loop to exit. Only valid within LOOP or ACCEPT structures.",
          "syntax": "BREAK [label]"
        }
      ]
    },
    {
      "name": "TIMES",
      "signatures": [
        {
          "params": [],
          "returnType": "",
          "description": "Used with LOOP to execute count number of iterations. Syntax: LOOP count TIMES. Executes the loop statements exactly count times. Simpler alternative to LOOP variable = 1 TO count when you don't need the counter variable.",
          "syntax": "LOOP count TIMES\n  statements\nEND"
        }
      ]
    },
    {
      "name": "PEEK",
      "signatures": [
        {
          "params": [
            { "name": "address", "optional": false },
            { "name": "destination", "optional": false }
          ],
          "returnType": "",
          "description": "Reads data from memory address into destination variable. Reads as many bytes as needed to fill destination. Use ADDRESS() to get correct address. DANGEROUS: Can cause GPF if reading invalid address. Use Windows API procedures instead when possible.",
          "syntax": "PEEK(address, destination)"
        }
      ]
    },
    {
      "name": "NULL",
      "signatures": [
        {
          "params": [
            { "name": "field", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Tests if database field contains null value. Returns non-zero (true) if field is null, zero (false) if field has known value (including blank/zero). For GROUP/RECORD, all components must be null to return true. Also used as constant for null reference assignment (e.g., variable &= NULL).",
          "syntax": "NULL(field) or NULL(file, field) or variable &= NULL"
        }
      ]
    },
    {
      "name": "CLOCK",
      "signatures": [
        {
          "params": [],
          "returnType": "LONG",
          "description": "Returns system time as hundredths of a second since midnight, plus one. Standard time format. Resolution limited to ~5.5 hundredths of a second (18.2 updates/sec) or 10-15ms on Windows NT systems. Range: 1 to 8,640,000.",
          "syntax": "CLOCK()"
        }
      ]
    },
    {
      "name": "TODAY",
      "signatures": [
        {
          "params": [],
          "returnType": "LONG",
          "description": "Returns operating system date as standard date. Standard date is number of days since December 28, 1800. Range: January 1, 1801 (standard date 4) to December 31, 2099 (standard date 109,211).",
          "syntax": "TODAY()"
        }
      ]
    },
    {
      "name": "DAY",
      "signatures": [
        {
          "params": [
            { "name": "date", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Returns day of month (1-31) from standard date. Date parameter can be numeric, variable, expression, or STRING with date picture token. Automatically converts date picture to standard date.",
          "syntax": "DAY(date)"
        }
      ]
    },
    {
      "name": "MONTH",
      "signatures": [
        {
          "params": [
            { "name": "date", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Returns month of year (1-12) from standard date. Date parameter can be numeric, variable, expression, or STRING with date picture token. Automatically converts date picture to standard date.",
          "syntax": "MONTH(date)"
        }
      ]
    },
    {
      "name": "YEAR",
      "signatures": [
        {
          "params": [
            { "name": "date", "optional": false }
          ],
          "returnType": "LONG",
          "description": "Returns four-digit year (1801-9999) from standard date. Date parameter can be numeric, variable, expression, or STRING with date picture token. Automatically converts date picture to standard date.",
          "syntax": "YEAR(date)"
        }
      ]
    }
  ]
}
